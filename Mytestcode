#include "main.h"
inline int MAXSIZE;
/// Insert text here //
// Implement Huffman tree for customer encoding
class HuffNode {
public:
	virtual ~HuffNode() {}
	virtual int weight() = 0;
	virtual bool isLeaf() = 0;
};
class LeafNode : public HuffNode{ // Lưu kí tự
private:
	char key;
	int wgt;
public:
	LeafNode(const char& key, int freq) { // Constructor Leaf Char
		this->key = key; this->wgt = freq;
	}
	char getK() { return this->key;}
	int weight() { return this->wgt;}
	bool isLeaf() { return true;}
};
class IntlNode : public HuffNode {
private:
	HuffNode* lc;
	HuffNode* rc;
	int wgt;
public:
	IntlNode(HuffNode* l, HuffNode* r) {
		this->wgt = l->weight() + r->weight();
		this->lc = l;
		this->rc = r;
	}
	int weight() { return this->wgt;}
	bool isLeaf() { return false;}
	HuffNode * left() const { return this->lc;} // const?
	void setLeft(HuffNode* temp) {this->lc = temp;}
	HuffNode * right() const { return this->rc;}
	void setRight(HuffNode* temp) {this->rc = temp;}
};
class HuffTree {
private:
	HuffNode* Root;
public:
	HuffTree(char& c, int freq) { // Leaf constructor
		Root = new LeafNode(c, freq);
	}
	// Internal node constructor
	HuffTree(HuffTree* l, HuffTree* r) {
		Root = new IntlNode(l->root(), r->root());
	}
	~HuffTree() {} // Destructor
	HuffNode* root() { return this->Root;} // Get root
	int weight() { return Root->weight();} // Root weight
};
struct Compare {
	bool operator() (pair<int, HuffTree*> a, pair<int, HuffTree*> b) {
		if(a.second->weight() != b.second->weight()) return a.second->weight() > b.second->weight();
		else return a.first > b.first;
	}
};
// Xây dựng cây Huff từ danh sách X
inline HuffTree* buildHuff(vector<pair<char,int>>& result) {
	priority_queue <pair<int, HuffTree*>, vector<pair<int, HuffTree*>>, Compare> forest; // create a min heap
	for(int i = 0; i < result.size(); i++) {
		HuffTree* tree = new HuffTree(result[i].first, result[i].second);
		forest.push(make_pair(i, tree));
	}
	HuffTree* temp1 = nullptr, *temp2 = nullptr, *temp3 = nullptr;
	int size = forest.size();
	int k = 1;
	while(forest.size() > 1) {
		temp1 = forest.top().second;
		forest.pop();
		temp2 = forest.top().second;
		forest.pop();
		temp3 = new HuffTree(temp1, temp2);
		forest.push(make_pair(size + k, temp3));
		k++;
		delete temp1;
		delete temp2;
	}
	return nullptr;
}
/// Insert text here ////
class Restaurant {
public:
	Restaurant() {

	}
	~Restaurant() {

	}
	class customer {

	};
	
	static bool cmp(pair <char, int> a, pair <char, int> b) { return a.second < b.second;}
	vector<pair<char,int>> frequency_sort(string name) {
		// Sort Frequency bằng map và pairs
		// Time complex: O(nlogn)
		// Space Aux: O(n)
		map <char, int> m;
		for(int i = 0; i < name.size(); i++) {
			m[name[i]] ++; // Giống key thì tăng value key đó lên 1
		}
		vector<pair<char, int>> result;
		for(map <char,int>::iterator it = m.begin(); it != m.end(); ++it) {
			result.push_back(*it);
		}
		stable_sort(result.begin(), result.end(), cmp);
		return result;
	}
	vector<pair<char,int>> caesar_encrypt(vector<pair<char, int>>& result) {
		//
		// Time complex: O(n)
		// Space Aux: O(1)
		int shift;
		for(int i = 0; i < result.size(); i++) {
			shift = result[i].second;
			if(isupper(result[i].first)) result[i].first = (result[i].first + shift - 'A') % 26 + 'A';
			else result[i].first = (result[i].first + shift - 'a') % 26 + 'a'; 
		}
		return result;
	}
	void LAPSE(string name) {
		vector<pair<char,int>> result = frequency_sort(name);
		result = caesar_encrypt(result);

	}
};
inline void simulate(string filename)
{
	Restaurant* r = new Restaurant();
	ifstream ss(filename);
	string str, maxsize, name;
	while(ss >> str) {
		if(str == "MAXSIZE") {
			ss >> maxsize;
			MAXSIZE = stoi(maxsize);
		}
		else if(str == "LAPSE") {
			ss >> name;
			r->LAPSE(name);
		}
		else if(str == "KOKUSEN") {

		}
		else if(str == "KEITEIKEN") {

		}
		else if(str == "HAND") {

		}
		else if(str == "LIMITLESS") {

		}
		else { // CLEAVE

		}
	}
	delete r;
	return;
}
